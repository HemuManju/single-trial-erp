from pathlib import Path              # Path handling for file operations
import mne                           # EEG/MEG data processing toolbox
import pandas as pd                  # Data handling, not used directly here but often for saving/loading tabular data
import numpy as np                   # Numerical operations (e.g., np.inf, np.searchsorted)

# Set the path to the raw BDF EEG data file
raw_path = Path(r"C:\Users\elahe\Downloads\sub-001_task-lumfront_eeg (1).bdf")

# Load the BDF EEG data, preload=True loads all data into RAM for faster access
raw = mne.io.read_raw_bdf(raw_path, preload=True)

print(raw)               # Print summary info about the raw object
print(raw.info)          # Print detailed info about EEG channels, sampling rate, etc.

# Plot the first 64 channels of the EEG data for inspection
raw.plot(n_channels=64, scalings='auto', title='Raw EEG Data', show=True)

# Plot the first 72 channels (in case you want to see more, e.g., EOG, triggers)
raw.plot(n_channels=72, scalings='auto', title='Raw EEG Data', show=True)

# Compute and plot the Power Spectral Density (PSD) up to 250 Hz, averaged across channels
fig = raw.compute_psd(tmax=np.inf, fmax=250).plot(
    average=True, amplitude=False, picks="data", exclude="bads"
)

# Add arrows to indicate power line noise and harmonics (60Hz, 120Hz, etc.) on the PSD plot
for ax in fig.axes[1:]:
    freqs = ax.lines[-1].get_xdata()       # Get frequency axis data
    psds = ax.lines[-1].get_ydata()        # Get power axis data
    for freq in (60, 120, 180, 240):       # Loop over common power line frequencies
        idx = np.searchsorted(freqs, freq) # Find the index closest to the target frequency
        ax.arrow(
            x=freqs[idx],
            y=psds[idx] + 18,              # Start arrow above the actual power value
            dx=0,
            dy=-12,                        # Arrow points downward
            color="red",
            width=0.1,
            head_width=3,
            length_includes_head=True,
        )

print(raw.info['ch_names'])    # Print all channel names (e.g., EEG, EOG, triggers)

# Pick only EEG, EOG, and stimulus (trigger) channels for further analysis
raw.pick(["eeg", "eog", "stim"])
raw.load_data()                # Ensure the selected data is loaded into memory

# Re-reference EEG signals to their average (common average reference)
raw.set_eeg_reference("average")

# Apply a bandpass filter: keeps frequencies between 0.3 and 40 Hz (removes slow drifts and high-frequency noise)
raw.filter(0.3, 40)

# === EVENT HANDLING AND EPOCHING ===

# Find events (e.g., triggers/markers in the stimulus channel)
events = mne.find_events(raw)

# Create a dictionary mapping event labels to event codes (according to your experiment)
event_id = {
    "REF_LIGHT": 11,
    "REF_DARK": 12,
    "RAND_LIGHT": 13,
    "RAND_DARK": 14
}

# Epoch the data: cut out segments (epochs) time-locked to the events of interest
epochs = mne.Epochs(raw, events, event_id=event_id, preload=True)

# Set y-axis limits for consistent plots of EEG/EOG (helps with visual comparison)
plot_kwargs = dict(picks="all", ylim=dict(eeg=(-10, 10), eog=(-5, 15)))

# Plot the average evoked response for all channels
fig = epochs.average("all").plot(**plot_kwargs)
fig.set_size_inches(6, 6)

# Save SSP (Signal Space Projection) projectors (used for artifact correction, if present)
ssp_projectors = raw.info["projs"]
raw.del_proj()     # Remove the projectors for now (optional, if you want to see raw data)

# === EOG (Eye Movement Artifact) ANALYSIS ===

# Extract and epoch segments time-locked to EOG events (eye blinks, saccades)
eog_epochs = mne.preprocessing.create_eog_epochs(raw, baseline=(-0.5, -0.2))
eog_epochs.plot_image(combine="mean")       # Visualize EOG epochs as images (time x trial)
eog_epochs.average().plot_joint()           # Joint plot (time series + topography)

